#!/bin/bash

set -e

# Created by argbash-init v2.7.1
# ARG_POSITIONAL_SINGLE([HOSTNAME])
# ARG_POSITIONAL_SINGLE([SECURITY_PROFILE])
# ARG_DEFAULTS_POS()
# ARG_HELP([<The general help message of my script>])
# ARGBASH_GO()
# needed because of Argbash --> m4_ignore([
### START OF CODE GENERATED BY Argbash v2.7.1 one line above ###
# Argbash is a bash code generator used to get arguments parsing right.
# Argbash is FREE SOFTWARE, see https://argbash.io for more info


die()
{
    local _ret=$2
    test -n "$_ret" || _ret=1
    test "$_PRINT_HELP" = yes && print_help >&2
    echo "$1" >&2
    exit ${_ret}
}


begins_with_short_option()
{
    local first_option all_short_options='h'
    first_option="${1:0:1}"
    test "$all_short_options" = "${all_short_options/$first_option/}" && return 1 || return 0
}

# THE DEFAULTS INITIALIZATION - POSITIONALS
_positionals=()
_arg_hostname=
_arg_security_profile=
# THE DEFAULTS INITIALIZATION - OPTIONALS


print_help()
{
    printf '%s\n' "<The general help message of my script>"
    printf 'Usage: %s [-h|--help] <HOSTNAME> <SECURITY_PROFILE>\n' "$0"
    printf '\t%s\n' "-h, --help: Prints help"
}


parse_commandline()
{
    _positionals_count=0
    while test $# -gt 0
    do
        _key="$1"
        case "$_key" in
            -h|--help)
                print_help
                exit 0
                ;;
            -h*)
                print_help
                exit 0
                ;;
            *)
                _last_positional="$1"
                _positionals+=("$_last_positional")
                _positionals_count=$((_positionals_count + 1))
                ;;
        esac
        shift
    done
}


handle_passed_args_count()
{
    local _required_args_string="'HOSTNAME' and 'SECURITY_PROFILE'"
    test "${_positionals_count}" -ge 2 || _PRINT_HELP=yes die "FATAL ERROR: Not enough positional arguments - we require exactly 2 (namely: $_required_args_string), but got only ${_positionals_count}." 1
    test "${_positionals_count}" -le 2 || _PRINT_HELP=yes die "FATAL ERROR: There were spurious positional arguments --- we expect exactly 2 (namely: $_required_args_string), but got ${_positionals_count} (the last one was: '${_last_positional}')." 1
}


assign_positional_args()
{
    local _positional_name _shift_for=$1
    _positional_names="_arg_hostname _arg_security_profile "

    shift "$_shift_for"
    for _positional_name in ${_positional_names}
    do
        test $# -gt 0 || break
        eval "$_positional_name=\${1}" || die "Error during argument parsing, possibly an Argbash bug." 1
        shift
    done
}

parse_commandline "$@"
handle_passed_args_count
assign_positional_args 1 "${_positionals[@]}"

# OTHER STUFF GENERATED BY Argbash

### END OF CODE GENERATED BY Argbash (sortof) ### ])
# [ <-- needed because of Argbash


printf "Value of '%s': %s\\n" 'HOSTNAME' "$_arg_hostname"
printf "Value of '%s': %s\\n" 'SECURITY_PROFILE' "$_arg_security_profile"

# ] <-- needed because of Argbash


HOSTNAME=""
SECURITY_PROFILE=""
ETC_DIR=""
SECURITY_PROFILE_FILE=""
USER_ATTRIBUTES_FILE=""
WORKING_FILE=""
log_file="./log_file.txt"
touch $log_file

# Set up function to be run at the beginning that handles setting the global variables defining
# file locations and command-line arguments.
function set_up() {
    HOSTNAME=$_arg_hostname
    SECURITY_PROFILE=$_arg_security_profile
    ETC_DIR="./"
    SECURITY_PROFILE_FILE="./profiles.json"
    USER_ATTRIBUTES_FILE="${ETC_DIR}user.attributes"

    # jq doesn't do in-place editing so we have to create a temporary working file to make our
    # modifications in
    WORKING_FILE="./jq_tmp_working.json"
    # use the current user attributes file as a starting point for the working file
    cp $USER_ATTRIBUTES_FILE $WORKING_FILE

    return 0
}

# Clean up function to be run at the end that handles removing any temporary files created during
# the script's operation.
function clean_up() {
    cat $log_file
    # jq '.' $WORKING_FILE
    rm $WORKING_FILE

    return 0
}

# Helper function to iterate through each attribute of the current property group of the selected
# profile and sets the key-value in the user attributes file.
# ${1} - Base64-encoded array of key-value pairings of attributes
# ${2} - Name of key to set the attributes for
# ${3} - Boolean of if the key of the object to be modified already exists in the current user 
#        attributes file
function set_attributes() {
    if [[ ${3} != true ]]; then
        # jq doesn't do in-place editing when setting values so we have to keep track of our
        # modifications in an object variable
        working_obj=$(jq --arg attr_key ${2} '.[ $attr_key ] = {}' $WORKING_FILE)
    else
        # throws an error if the given key does not actually exist in the user attributes file
        if [[ $(jq --arg attr_key ${2} '.[ $attr_key ]' $WORKING_FILE) = "null" ]]; then
            echo "Key \"${2}\" does not exist in the user attributes file."
            exit 1;
        fi
        # don't need to assign a new key object so use the original unmodified JSON
        working_obj=$(jq '.' $WORKING_FILE)
    fi

    # decodes the given array and compacts the output so we can loop through it and get each key
    # and associated value
    for attribute in $(echo ${1} | base64 --decode | jq -c '.[]'); do
        property_key=$(echo $attribute | jq -r '.key')
        property_value=$(echo $attribute | jq -r '.value')
        # array values need to be handled differently than strings
        if [[ $(echo $attribute | jq -r '.value | type') = "array" ]]; then
            # initializes an array to hold the property values for the current attribute
            working_obj=$(echo $working_obj | jq -r --arg attr_key ${2} --arg key $property_key \
                    '.[ $attr_key ][ $key ] = []')
            # iterates through the values in the array of property values and appends each to the
            # array created for the current attribute
            for arr_val in $(echo $property_value | jq -r '.[]'); do
                working_obj=$(echo $working_obj | jq -r --arg attr_key ${2} --arg key $property_key \
                    --arg value $arr_val '.[ $attr_key ][ $key ] += [ $value ]')
            done
        else
            # sets the current attribute and reassigns the output to the tracked working object variable
            working_obj=$(echo $working_obj | jq -r --arg attr_key ${2} --arg key $property_key \
                    --arg value $property_value '.[ $attr_key ][ $key ] = $value')
        fi
    done

    # return the base64 encoded working object variable with all the new attributes
    echo $(echo $working_obj | jq -r '@base64')
    return 0
}

# Sets the properties for the designated config files.
# ${1} - Base64-encoded array of config properties
function set_config_properties() {
    # iterates through the config objects and sets the properties in the specified locations
    # we have to base64 encode the config objects to prevent jq from wrapping the whitespaces with
    # single quotes and causing the parser to break
    for config in $(echo ${1} | base64 --decode | jq -r '.[] | @base64'); do
        pid=$(echo $config | base64 --decode | jq -r '.value.pid')
        properties=$(echo $config | base64 --decode | jq -r '.value.properties | to_entries | .[]')
        # @TODO - locate the config file to modify
        # config_file=$()
        for property in $(echo $properties | jq -r '@base64'); do
            property_key=$(echo $property | base64 --decode | jq -r '.key')
            property_value=$(echo $property | base64 --decode | jq -r '.value')
            echo "${property_key}: \"${property_value}\"" >> $log_file
            # use oconnormi's props command line tool for editing config files
            # props set $property_key $property_value $config_file
        done
    done

    return 0
}

# Parses the JSON object for the selected security profile and gets the groups of properties
# ${1} - Base64-encoded JSON object with the properties of the selected profile
function set_profile_properties() {
    decoded_profile_attributes=$(echo ${1} | base64 --decode)
    guest_claims=$(echo $decoded_profile_attributes | jq -r '.guestClaims | to_entries | @base64')
    system_claims=$(echo $decoded_profile_attributes | jq -r '.systemClaims | to_entries | @base64')
    configs=$(echo $decoded_profile_attributes | jq -r '.configs | to_entries | @base64')

    # writes the final modified objects to the working file
    echo $(echo $(set_attributes $guest_claims "guest" false) | base64 --decode | jq '.') \
            > $WORKING_FILE
    echo $(echo $(set_attributes $system_claims $HOSTNAME true) | base64 --decode | jq '.') \
            > $WORKING_FILE
    echo $(set_config_properties $configs)
    return 0
}

# Main function to run when the script is started.
function main() {
    set_up

    if [[ ! -d $ETC_DIR || ! -f $SECURITY_PROFILE_FILE ]]; then
        echo "Unable to find the security profile JSON file."
        exit 1;
    elif [[ ! -f $USER_ATTRIBUTES_FILE ]]; then
        echo "Unable to find the user attributes file."
        exit 1;
    fi

    profile_attributes=$(jq -r --arg key $SECURITY_PROFILE '.[ $key ] | @base64' $SECURITY_PROFILE_FILE)
    set_profile_properties $profile_attributes
    clean_up
    return 0
}

main
